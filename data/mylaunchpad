#!/usr/bin/python 
##Note: For run in arch linux change python to pyhton2
import os, sys
import pygtk
import logging
import re
import threading
import signal
import ConfigParser
from appsmenu import MenuCache
from subprocess import call
pygtk.require('2.0')

# checking for already running process

home_dir = os.path.expanduser('~')

if os.path.isfile(home_dir+'/.mylaunchpad_lock'):
    mylaunchpad_lock_file = open(home_dir+"/.mylaunchpad_lock", "r")
    pid = int(mylaunchpad_lock_file.readline())
    do_exit = True
    try:
        os.kill(pid, signal.SIGKILL)
    except:
        # some error
        do_exit = False
    os.remove(home_dir+'/.mylaunchpad_lock')
    mylaunchpad_lock_file.close()
    if do_exit:
        exit()

mylaunchpad_lock_file = open(home_dir+"/.mylaunchpad_lock", "w")
mylaunchpad_lock_file.write(str(os.getpid()) + "\n")
mylaunchpad_lock_file.close()

ICON_SIZE = 64
ROW_PADDING = 24
COL_PADDING = 16
BUTTON_PADDING = 16
CONTAINER_PADDING = 1
OPACITY = 75


#default configuration
POWER_BUTTON = True
GOOGLE_SEARCH = True

#default commands
INTERNAL_MENU_SHUTDOWN_COMMAND = "sudo shutdown -h now"
INTERNAL_MENU_REBOOT_COMMAND   = "sudo reboot"
INTERNAL_MENU_LOCK_COMMAND = ""
INTERNAL_MENU_LOGOUT_COMMAND = "dbus-send --session --type=method_call --print-reply --dest=org.gnome.SessionManager /org/gnome/SessionManager org.gnome.SessionManager.Logout uint32:1"
INTERNAL_MENU_SUSPEND_COMMAND = "python -u /usr/lib/zorinmenu/session-manager.py suspend"

try:
    from lxml import etree
except:
    print "lxml missing, please install pyhton-lxml "
    sys.exit()

try:
    import gtk
except:
    print "pyGTK missing, install python-gtk2"
    sys.exit()

try:
    import cairo
except:
    print "Cairo modules missing, install python-cairo"

try:
    from PIL import Image, ImageFilter
except:
    print "PIL missing, install python-imaging"
    sys.exit()
    
def import_favor():
    global favorite
    if os.path.isfile(home_dir+"/.mylaunchpadFavor"):
        favors = open(home_dir+"/.mylaunchpadFavor", "r")
        favorite = eval(favors.readline())
        print "Favorites imported: ", favorite
    else:
        favorite = set()
        export_favor()
        print "Favorites imported as empty"

def export_favor():
    favors = open(home_dir+"/.mylaunchpadFavor", "w")
    favors.write(str(favorite) + "\n")
    favors.close()
    print "Favorites exported"
    
def import_hidden():
    global hidden
    if os.path.isfile(home_dir+"/.mylaunchpadHidden"):
        hiddens = open(home_dir+"/.mylaunchpadHidden", "r")
        hidden = eval(hiddens.readline())
        print "Hidden imported: ", hidden
    else:
        hidden = set()
        export_hidden()
        print "Hidden imported as empty"

def export_hidden():
    hiddens = open(home_dir+"/.mylaunchpadHidden", "w")
    hiddens.write(str(hidden) + "\n")
    hiddens.close()
    print "Hidden exported"

favorite = set()
hidden = set()

import_hidden()
import_favor()


class AppStore:
    def __init__(self, mainbox, launcher):
        self.window = launcher.window
        self.window.set_skip_taskbar_hint(True)
        self.window.stick()
        self.window.connect("key-press-event", self.on_keypress)
        self.window.connect("notify::is-active", self.focus_window)
        self.mainbox = mainbox
        self.cur_page = 1
        self.cur_category = "ALL"
        
        self.window.set_modal(True)
        
        # Get Menu
        menu = MenuCache(AUTO_UPDATE=True, xdg_menu = launcher.xdg_menu)
        self.appsmenu = menu.getMenu()

        #update cache in the background
        t = threading.Thread(target=menu.updateCache())  
        t.start() 

        # Get Categories
        categories = self.getCategories()
        
        
        # Create containers
        self.mainContainer = gtk.HBox(False, 0)
        self.buttonsContainer = gtk.VBox(False)

        # Get maxcolums and max rows
        self.maxcolums = self.calculate_maxcolums()
        self.maxrows = self.calculate_maxrows()
        
        # Get system font size
        self.font_style = self.buttonsContainer.get_style().font_desc.to_string()
        self.fontsize = int(re.search(r"(\d+)", self.font_style).group(1))        
        # Pack in the button container box into main container box, with two padder boxes
        self.mainContainer.pack_start(gtk.HBox(), True, True)
        self.mainContainer.pack_start(self.buttonsContainer, False, True, 0)
        self.mainContainer.pack_start(gtk.HBox(), True, True)
        
        #add toolbar
        self.add_toolbar(mainbox, categories, launcher)
        
        #add main container to main box
        mainbox.pack_start(self.mainContainer)
        
        self.load("ALL")
        self.search.connect("key-release-event", self.activate_search)
        self.search.connect("key-press-event", self.enable_search)
        self.search.set_editable(False)
        self.window.set_focus(None)
        self.window.add(mainbox)
        self.window.maximize() # HOT FIX

    def on_keypress(self, widget, event):
        if gtk.gdk.keyval_name(event.keyval) == "Page_Down":
            self.window.set_focus(None)
            if self.cur_page < self.max_pages:
                self.cur_page += 1
                self.navigate_page(None, None, self.apps, self.cur_page)
        elif gtk.gdk.keyval_name(event.keyval) == "End":
            self.window.set_focus(None)
            if self.cur_page != self.max_pages:
                self.cur_page = self.max_pages
                self.navigate_page(None, None, self.apps, self.cur_page)
        elif gtk.gdk.keyval_name(event.keyval) == "Home":
            self.window.set_focus(None)
            if self.cur_page != 1:
                self.cur_page = 1
                self.navigate_page(None, None, self.apps, self.cur_page)
        elif gtk.gdk.keyval_name(event.keyval) == "Page_Up":
            self.window.set_focus(None)
            if self.cur_page > 1:
                self.cur_page -= 1
                self.navigate_page(None, None, self.apps, self.cur_page)
        elif (self.search.get_text() in ["", "Start typing..."] and not self.search.get_editable()) and gtk.gdk.keyval_name(event.keyval) in ["1", "2", "3", "4", "5", "6", "7", "8", "9"]:
            if int(gtk.gdk.keyval_name(event.keyval)) <= self.max_pages:
                self.cur_page = int(gtk.gdk.keyval_name(event.keyval))
                self.navigate_page(None, None, self.apps, self.cur_page)
        elif (self.search.get_text() in ["", "Start typing..."] or not self.search.get_editable()) and gtk.gdk.keyval_name(event.keyval) not in ["Left", "Right", "Up","Down", "Page_Up", "Page_Down", "Tab"]:
            self.window.set_focus(self.search)
        return

    def focus_window(self, widget, event):
        self.window.present()
        
    def showResults(self, results):
        self.buttonContainer_size_w = self.buttonsContainer.get_allocation().width
        self.buttonContainer_size_h = self.buttonsContainer.get_allocation().height
        if self.buttonsContainer.get_children():
           for widget in self.buttonsContainer.get_children():
              self.buttonsContainer.remove(widget)
           self.buttonsContainer.set_size_request(self.buttonContainer_size_w, self.buttonContainer_size_h) 
        self.fill_buttonsContainer(results)   
        self.buttonsContainer.show_all()
    #load apps
    def load(self, id_category):
        self.buttonContainer_size_w = self.buttonsContainer.get_allocation().width
        self.buttonContainer_size_h = self.buttonsContainer.get_allocation().height
        if self.buttonsContainer.get_children():
           for widget in self.buttonsContainer.get_children():
              self.buttonsContainer.remove(widget)
           self.buttonsContainer.set_size_request(self.buttonContainer_size_w, self.buttonContainer_size_h) 
        apps = self.getApps(id_category)
        self.fill_buttonsContainer(apps)   
        self.buttonsContainer.show_all()
        self.window.set_focus(None)

    def enter_callback(self, widget):
        self.run_command(self.getResults(self.search.get_text())[0]['command'])
        
    def search_lost_focus(self, widget=None, event=None, data=None):
        self.search.set_editable(False)
        if not self.search.get_text():
          self.search.set_text("Start typing...")
        self.buttonsContainer.get_children()[0].get_children()[0].get_children()[0].grab_focus()
        self.buttonsContainer.get_children()[0].get_children()[0].get_children()[0].set_relief(gtk.RELIEF_NORMAL)
        
    def enable_search(self, widget=None, event=None, data=None):
       if not self.search.get_editable() and gtk.gdk.keyval_name(event.keyval) not in ["1", "2", "3", "4", "5", "6", "7", "8", "9"]:
          if self.search.get_text() == "Start typing...":
             self.search.set_text("")
          self.search.set_editable(True)
          self.search.grab_focus()
          
    def activate_search(self, widget=None, event=None, data=None):
       if gtk.gdk.keyval_name(event.keyval) in ["Page_Down", "Page_Up","Left","Right","Up", "Down",  "Tab"]:
           return 
       else:
          if self.search.get_text() and self.search.get_text() !=  "Start typing...": 
              self.showResults(self.getResults(self.search.get_text()))
          else:
              self.load("ALL")
          try:
            #self.buttonsContainer.get_children()[0].get_children()[0].get_children()[0].grab_focus()
            self.buttonsContainer.get_children()[0].get_children()[0].get_children()[0].set_relief(gtk.RELIEF_NORMAL)
          except:
            print "No result"
       self.navigate_page(None, None, self.apps, 1)

    def add_toolbar(self, widget, categories, launcher):
        toolbar_container = gtk.HBox(False)

        # create toolbar
        toolbar = gtk.HBox(False)
        self.toolbar = toolbar
        toolbar.set_border_width(5)
        
        toolbar_container.pack_start(gtk.HBox()) #
        
        toolbar.pack_start(gtk.HBox())
        # Add Categories as buttons
        button = gtk.Button(" All ")
        button.category_id = "ALL"
        button.set_relief(gtk.RELIEF_NORMAL)
        button.child.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("black"))
        button.set_focus_on_click(False)
        button.set_border_width(0)
        button.set_property('can-focus', False)
        button.connect("clicked", self.activate_category, "ALL")
        toolbar.pack_start(button, False, False, 0)
        
        button = gtk.Button(" Favorite ")
        button.category_id = "FAVOR"
        button.set_relief(gtk.RELIEF_NONE)
        button.child.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
        button.set_focus_on_click(False)
        button.set_border_width(0)
        button.set_property('can-focus', False)
        button.connect("clicked", self.activate_category, "FAVOR")
        toolbar.pack_start(button, False, False, 0)
        for category in categories:
           button = gtk.Button(' '+category['label']+' ')
           button.category_id = category['id']
           button.set_relief(gtk.RELIEF_NONE)
           button.child.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
           button.set_focus_on_click(False)
           button.set_border_width(0)
           button.set_property('can-focus', False)
           button.connect("clicked", self.activate_category, category['id'])
           toolbar.pack_start(button, False, False, 0)
           
        #shutdown button
        
        if launcher.power_button:
           self.btnshutdown = gtk.Button()
           self.btnshutdown.add(self.get_icon("system-shutdown-symbolic",24))
           self.btnshutdown.set_relief(gtk.RELIEF_NONE)
           self.btnshutdown.set_property('can-focus', False)
           if not launcher.custom_power_manager or launcher.custom_power_manager == 'none' :
              self.btnshutdown.connect("clicked", self.get_shutdown_menu)
           else:
              self.btnshutdown.connect_object("clicked", self.run_command, launcher.custom_power_manager)
 
           toolbar.pack_end(self.btnshutdown)

           
        # Add search box
        self.search = gtk.Entry()
        self.search.set_editable(False)
        #self.search.set_property('can-focus', False)
        self.search.set_text("Start typing...")
        self.search.connect("activate", self.enter_callback)
        self.search.connect("focus-out-event", self.search_lost_focus)
        #self.search.connect("focus-in-event", self.enable_search)
        
        toolbar.pack_end(gtk.HBox())
        toolbar.pack_end(self.search, False, False, 5)
        
        # Add toolbar to widget
        
        toolbar_container.pack_start(toolbar, False , False, 0)
        toolbar.pack_start(gtk.HBox())
        
        toolbar_container.pack_start(gtk.HBox()) #
        widget.pack_start(toolbar_container, False , False, 30)
    
    # closing the window from the WM
    def destroy(self, widget=None, event=None):
        gtk.main_quit()
        return False
        
    #Calculate max columns 
    def calculate_maxcolums(self):   
       maxcolums = (gtk.gdk.screen_width() / (ICON_SIZE + COL_PADDING*2 + BUTTON_PADDING*2+CONTAINER_PADDING*2))
       return maxcolums
    
    #Calculate max row
    def calculate_maxrows(self):   
        maxrows = (gtk.gdk.screen_height() / (ICON_SIZE*2 + ROW_PADDING*2 + BUTTON_PADDING*2))
        return maxrows
    
    # Get icon
    def get_icon(self, icon_name, size = ICON_SIZE):
        try:
           theme = gtk.icon_theme_get_default()
           pixbuf = theme.load_icon(icon_name.split('.')[0],size, 0)
           return gtk.image_new_from_pixbuf(pixbuf)
        except:
           if not icon_name or not os.path.exists(icon_name):
               pixbuf = theme.load_icon("exec",size, 0)
               return gtk.image_new_from_pixbuf(pixbuf)
           return gtk.image_new_from_file (icon_name)

    def paginate(self, lista):
        nPages = (len(lista) / (self.maxcolums * self.maxrows)) + 1
        #print "pages: " + str(nPages)
        paginationbox = gtk.HBox()
        footer = gtk.HBox()
        self.apps = lista
        self.max_pages = nPages
        if nPages > 1:
            for i in range(1,nPages+1):
                button = gtk.Button()
                button.set_relief(gtk.RELIEF_NORMAL)
                if self.cur_page == i:
                    button.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
                else:
                    button.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse("black"))
                button.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
                button.set_focus_on_click(False)
                button.set_border_width(0)
                button.set_property('can-focus', False)
                button.connect("button-press-event", self.navigate_page, lista, i)
                label = gtk.Label()
                label.set_use_markup(True)
                label.set_markup('<span color="#808080"><b>'+"   "+str(i)+"   "+'</b></span>')
                button.add(label)
                label.show()
                paginationbox.pack_start(button, False , False, 0)
            #paginationbox.pack_start(gtk.Label("            Page: " + str(self.cur_page)), False, False, 5)
        footer.pack_start(gtk.HBox())
        footer.pack_start(paginationbox, False , False, 0)
        footer.pack_start(gtk.HBox())
        self.buttonsContainer.pack_end(footer, False , False, 0)

    def fill_buttonsContainer(self, lista, Page=1):
        self.paginate(lista)
    
        #row_widget = self.new_row(self.buttonsContainer)
        iconCounter=0
        rowCounter=0
        i = {
                'icon': 'find-location-symbolic',
                'command': "python -c 'import webbrowser; webbrowser.open(\"http://www.google.com/?q=#q="+self.search.get_text()+"\")'",
                'label': 'Find '+self.search.get_text()
            }
        if (self.search.get_text() not in ["", "Start typing..."]) and GOOGLE_SEARCH:
            addition = [i]
        else:
            addition = []
        for item in lista[(self.maxrows*self.maxcolums)*(Page-1):(self.maxrows*self.maxcolums)*(Page)]+addition:
               if (iconCounter)%self.maxcolums == 0:
                  rowCounter+=1
                  row_widget = self.new_row(self.buttonsContainer)
               iconCounter+=1
               self.add_button(item, row_widget)

    def new_row(self, widget):
        row=gtk.HBox(False)
        widget.pack_start(row, False, False, ROW_PADDING)
        return row

    def add_button(self, item, row):
        """ Add a button to the panel """
        if item['label'] != 'MyLaunchpad':
            box = gtk.VBox(False)

            image = gtk.Image()
            button = gtk.Button()
            button.set_relief(gtk.RELIEF_NONE)
            #gtk.RELIEF_NORMAL
            #button.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
            #button.set_property('opacity', 0.3)
            button.set_focus_on_click(False)
            button.set_border_width(0)
            button.set_property('can-focus', True)
            icon_name = item['icon']
            icon = self.get_icon(icon_name)
            button.add(icon)
            button.set_size_request(ICON_SIZE+BUTTON_PADDING, ICON_SIZE+BUTTON_PADDING)
            button.show()
            box.pack_start(button, False, False, BUTTON_PADDING)
            button.connect("button-release-event", self.click_button, item)
            button.connect("focus-in-event", self.in_focus)
            button.connect("focus-out-event", self.out_focus)
            labelString = item['label']
            ## label to big
            if len(item['label']) > 15:
                if len(item['command']) < 15:
                   labelString = item['command'].replace('-', ' ').capitalize()
            if len(labelString) * self.fontsize > ICON_SIZE+BUTTON_PADDING*2:
                labelString = item['label'][0:((ICON_SIZE+BUTTON_PADDING*2) / self.fontsize)]+"..."
            label = gtk.Label(labelString)
            label.set_tooltip_text(item['label'])
            button.set_tooltip_text(item['label'])
            label.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
            #if len(labelString) > 12:
               #label.set_line_wrap(True)
            label.set_justify(gtk.JUSTIFY_CENTER)
            
            box.set_size_request(ICON_SIZE+BUTTON_PADDING*2, ICON_SIZE*2)
            box.pack_end(label, False, True)
        
            row.pack_start(box, False, False, COL_PADDING)

    def click_button(self, widget, event, item):
        if event.button == 1:
            self.run_command(item['command'])
        if event.button == 3:
            self.get_right_click_menu(widget, item)

    def in_focus(self, widget, event):
        widget.set_relief(gtk.RELIEF_NORMAL)
        

    def out_focus(self, widget, event):
        widget.set_relief(gtk.RELIEF_NONE)

    def activate_category(self, widget, category_id):
        self.cur_page = 1
        self.cur_category = category_id
        widget.child.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("black"))
        children = self.toolbar.get_children()
        
        for x in children:
            try:
                x.category_id
            except:
                continue
            if x.category_id == category_id:
                x.set_relief(gtk.RELIEF_NORMAL)
            else:
                x.set_relief(gtk.RELIEF_NONE)
                x.child.modify_fg(gtk.STATE_NORMAL, gtk.gdk.color_parse("white"))
        self.load(category_id)

    def navigate_page(self, widget, event, apps, page):
        if (event is None) or (event.button == 1):
            self.cur_page = page
            self.buttonContainer_size_w = self.buttonsContainer.get_allocation().width
            self.buttonContainer_size_h = self.buttonsContainer.get_allocation().height
            if self.buttonsContainer.get_children():
               for widget in self.buttonsContainer.get_children():
                  self.buttonsContainer.remove(widget)
               self.buttonsContainer.set_size_request(self.buttonContainer_size_w, self.buttonContainer_size_h) 
            self.fill_buttonsContainer(apps, Page=page) 
            self.buttonsContainer.show_all()
        
    def run_command(self, command):
         self.destroy()
         print "%s pressed" %command
         os.system(command + ' &')
         
    def hide_app(self, item):
        hidden.add(item['label'])
        self.activate_category(None, self.cur_category)
    
    def fav_unfav(self, item):
        if item['label'] in favorite:
            favorite.discard(item['label'])
            self.activate_category(None, self.cur_category)
        else:
            favorite.add(item['label'])
    
    def get_right_click_menu(self, widget, item):       
        menu = gtk.Menu()
        
        # fav/unfav
        if item['label'] in favorite:
            mItemFav = gtk.MenuItem("unfavorite")
        else:
            mItemFav = gtk.MenuItem("favorite")
            
        menu.append(mItemFav)
        mItemFav.connect_object("activate", self.fav_unfav, item)
        
        # hide apps
        mItemHide = gtk.MenuItem("hide")
        menu.append(mItemHide)
        mItemHide.connect_object("activate", self.hide_app, item)

        menu.show_all()
        gtk.Menu.popup(menu, None, None, None, 1, 0)

    def get_shutdown_menu(self, widget):
        
        menu = gtk.Menu()
        
        for cmd in launcher.config.get('options', 'power_options').replace(' ', '').split(','): 
            if cmd == "shutdown" and launcher.shutdown_cmd:
                item = gtk.MenuItem("Shutdown")
                menu.append(item)
                item.connect_object("activate", self.run_command, launcher.shutdown_cmd)
                continue
            if cmd == "reboot" and launcher.reboot_cmd:
                item = gtk.MenuItem("Reboot")
                menu.append(item)
                item.connect_object("activate", self.run_command, launcher.reboot_cmd)
                continue
            if cmd == "suspend" and launcher.suspend_cmd:
                item = gtk.MenuItem("Suspend")
                menu.append(item)
                item.connect_object("activate", self.run_command, launcher.lock_cmd + ' & ' + launcher.suspend_cmd)
                continue
            if cmd == "lock" and launcher.lock_cmd:
                item = gtk.MenuItem("Lock")
                menu.append(item)
                item.connect_object("activate", self.run_command, launcher.lock_cmd)
                continue
            if cmd == "logout" and launcher.logout_cmd:
                item = gtk.MenuItem("Logout")
                menu.append(item)
                item.connect_object("activate", self.run_command, launcher.logout_cmd)
                continue
            print "->Error! Wrong command option: " + cmd + " in the config file\n"
            
        menu.show_all()
        gtk.Menu.popup(menu, None, None, None, 1, 0)
        

     
    def isHiddenItem(self, label):
        if label in hidden:
            return True
        return False
        
        
     ## xpath tutorial:
     ## http://www.w3schools.com/xpath/xpath_syntax.asp

    def getApps(self, Category="ALL", Page=1):
       root = etree.parse(self.appsmenu)
       apps = []
       if Category == "ALL": 
          for item in root.xpath("/xdg-menu/menu[@id]/item[@label!='MyLaunchpad']"):
             if not self.isHiddenItem(item.attrib["label"]):
                 apps.append({'label': item.attrib["label"], 'icon': item.attrib["icon"], 'command': item.find(".//command").text})
       elif Category == "FAVOR":
          for item in root.xpath("/xdg-menu/menu[@id]/item"):
              if item.attrib["label"] in favorite:
                apps.append({'label': item.attrib["label"], 'icon': item.attrib["icon"],
                    'command': item.find(".//command").text})
       else:
          for item in root.xpath("/xdg-menu/menu[@id='"+Category+"']/item[@label!='MyLaunchpad']"):
              if not self.isHiddenItem(item.attrib["label"]):
                 apps.append({'label': item.attrib["label"], 'icon': item.attrib["icon"], 'command': item.find(".//command").text})
       return apps

    def getCategories(self):
       root = etree.parse(self.appsmenu)
       categories = []
       for item in root.xpath("/xdg-menu/menu[@id]"):
          categories.append({'id': item.attrib["id"], 'label': item.attrib["label"]})
       return categories

    def getResults(self, search):
       root = etree.parse(self.appsmenu)
       results = []
       for item in root.xpath("/xdg-menu/menu[@id]/item[contains(@label, '" + search + "') or contains(@id, '" + search + "') or contains(@icon, '" + search + "') or contains(translate(.//command, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '" + search + "')]"):
          if not self.isHiddenItem(item.attrib["label"]): 
              results.append({'label': item.attrib["label"], 'icon': item.attrib["icon"], 'command': item.find(".//command").text})
       return results
    
class MyLauncher:
    def __init__(self):
        global GOOGLE_SEARCH
        # Start logger
        self.logger = logging.getLogger(self.__class__.__name__)
        
        #read config
        self.config = ConfigParser.RawConfigParser()
        self.config.read('/etc/mylaunchpad.conf')

        
        self.power_button = self.read_bool_item_config('options', 'power_button', POWER_BUTTON)
        GOOGLE_SEARCH = self.read_bool_item_config('options', 'google_search', GOOGLE_SEARCH)
        self.custom_power_manager = self.read_item_config('options', 'custom_power_manager', 'none')
        self.xdg_menu =  self.read_item_config('options', 'xdg-menu', 'default')
                
        self.shutdown_cmd = self.read_item_config('commands', 'shutdown', INTERNAL_MENU_SHUTDOWN_COMMAND)
        self.reboot_cmd = self.read_item_config('commands', 'reboot', INTERNAL_MENU_REBOOT_COMMAND)
        self.suspend_cmd = self.read_item_config('commands', 'suspend', INTERNAL_MENU_SUSPEND_COMMAND)
        self.lock_cmd = self.read_item_config('commands', 'lock', INTERNAL_MENU_LOCK_COMMAND)
        self.logout_cmd = self.read_item_config('commands', 'logout', INTERNAL_MENU_LOGOUT_COMMAND)
        
        
        # bgcolor and opacity
        self.opacity = OPACITY
        self.bgcolor = gtk.gdk.color_parse("black")
        self.init_window()
        
    def read_item_config (self, section, option, default = ""):
        if self.config.has_section(section):
            if self.config.has_option(section, option):
                return self.config.get(section, option)
        return default
        
    def read_bool_item_config (self, section, option, default = False):
        if self.config.has_section(section):
            if self.config.has_option(section, option):
                return self.config.getboolean(section, option)
        return default
    
    def quit(self, widget=None, data=None):
        export_favor()
        export_hidden()
        os.remove(home_dir+'/.mylaunchpad_lock')
        gtk.main_quit()

    def on_keypress(self, widget=None, event=None, data=None):
        #print("Keypress: %s/%s" % (event.keyval, gtk.gdk.keyval_name(event.keyval)))
        if gtk.gdk.keyval_name(event.keyval) == "Escape":
            self.quit()
            
    def on_window_state_change(self, widget, event, *args):
        if event.new_window_state & gtk.gdk.WINDOW_STATE_FULLSCREEN:
            self.window_in_fullscreen = True
        else:
            self.window_in_fullscreen = False
    
    def on_screen_changed(self, widget, old_screen=None):

        # To check if the display supports alpha channels, get the colormap
        screen = widget.get_screen()
        self.colormap = screen.get_rgba_colormap()
        if self.colormap == None:
            self.logger.debug("Screen does not support alpha channels!")
            colormap = screen.get_rgb_colormap()
            self.supports_alpha = False
        else:
            self.logger.debug("Screen supports alpha channels!")
            self.supports_alpha = True

        # Now we have a colormap appropriate for the screen, use it
        widget.set_colormap(self.colormap)

    def on_expose(self, widget, event):

        cr = widget.window.cairo_create()

        if self.supports_alpha == True:
            cr.set_source_rgba(1.0, 1.0, 1.0, 0.0) # Transparent
        else:
            cr.set_source_rgb(1.0, 1.0, 1.0) # Opaque white

        # Draw the background
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.paint()

        #(width, height) = widget.get_size()
        cr.set_source_rgba(self.bgcolor.red, self.bgcolor.green, self.bgcolor.blue, float(self.opacity)/100)

        cr.rectangle(event.area.x, event.area.y, event.area.width, event.area.height)
        cr.fill()

        
        cr.stroke()
        return False

    def init_window(self):
         # Start pyGTK setup
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title("MyLaunchpad")
        self.window.set_keep_above(True)
        self.window.add_events(gtk.gdk.BUTTON_PRESS_MASK)
        

        self.window.connect("destroy", self.quit)
        self.window.connect("button-press-event", self.quit)
        self.window.connect("key-press-event", self.on_keypress)
        self.window.connect("window-state-event", self.on_window_state_change)

        
        if not self.window.is_composited():
            self.logger.debug("No compositing, enabling rendered effects")
            # Window isn't composited, enable rendered effects
            self.rendered_effects = True
        else:
            # Link in Cairo rendering events
            #self.window.connect("delete_event", self.delete_event)
            self.window.connect('expose-event', self.on_expose)
            self.window.connect('screen-changed', self.on_screen_changed)
            self.on_screen_changed(self.window)
            self.rendered_effects = False
        print "Compositing %s" %self.window.is_composited()

        self.window.set_size_request(620,200)
        self.window.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse("black"))

        self.window.set_decorated(False)
        self.window.set_position(gtk.WIN_POS_CENTER)

        mainbox = gtk.VBox(False, 0);
    
        apps = AppStore(mainbox, self)

        if self.rendered_effects == True:
            self.logger.debug("Stepping though render path")
            w = gtk.gdk.get_default_root_window()
            sz = w.get_size()
            pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
            pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])

            self.logger.debug("Rendering Fade")
            # Convert Pixbuf to PIL Image
            wh = (pb.get_width(),pb.get_height())
            pilimg = Image.fromstring("RGB", wh, pb.get_pixels())

            pilimg = pilimg.point(lambda p: (p * self.opacity) / 255 )

            # "Convert" the PIL to Pixbuf via PixbufLoader
            buf = StringIO.StringIO()
            pilimg.save(buf, "ppm")
            del pilimg
            loader = gtk.gdk.PixbufLoader("pnm")
            loader.write(buf.getvalue())
            pixbuf = loader.get_pixbuf()

            # Cleanup IO
            buf.close()
            loader.close()

            pixmap, mask = pixbuf.render_pixmap_and_mask()
            # width, height = pixmap.get_size()
        else:
            pixmap = None

        self.window.set_app_paintable(True)
        self.window.resize(gtk.gdk.screen_width(), gtk.gdk.screen_height())
        self.window.realize()

        if pixmap:
            self.window.window.set_back_pixmap(pixmap, False)
        self.window.move(0,0)
        

    def run_launcher(self):
        #gtk.rc_parse('rc')
        self.window.show_all()
        
        gtk.main()

launcher = MyLauncher()
launcher.run_launcher()
